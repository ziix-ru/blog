---
title: "Связываем Caddy и Docker: Почему Labels победили Config Files"
date: 2025-12-08T06:10:00+03:00
draft: false
description: "В битве между чистотой Ansible и удобством Docker я выбрал второе. Рассказываю, как построить безопасную атомарную инфраструктуру с Caddy и Socket Proxy."
tags: ["docker", "caddy", "ansible", "security", "architecture"]
categories: ["DevOps", "HomeLab"]
---

Когда начинаешь писать свою Ansible-коллекцию для инфраструктуры (в моем случае — стек с AmneziaWG, мониторингом и Caddy), неизбежно упираешься в архитектурную развилку: **как связывать сервисы между собой?**

Конкретнее: как объяснить обратному прокси (Caddy), что у нас поднялся новый контейнер и ему нужен HTTPS?

В учебниках по Ansible и "правильному DevOps" ответ однозначный: **Config Files**.
В реальности Docker-комьюнити ответ тоже однозначный, но другой: **Labels**.

Я стоял перед этим выбором, переписывая роль для Amnezia, и решил зафиксировать, почему я сознательно пошел по "неканоничному" пути.

### Путь 1: Файлы (The Ansible Way)

Идея проста: Ansible — это система управления конфигурациями. Значит, он должен генерировать конфиги.
Роль `amnezia` должна сгенерировать файл `amnezia.caddy` и положить его в папку `/etc/caddy/sites/`.

**Почему я сказал "Нет":**
1.  **Нарушение границ ответственности.** Роль VPN-сервиса внезапно должна знать внутреннюю структуру папок роли веб-сервера.
2.  **Рассинхрон состояний.** Контейнер может упасть, а файл конфига останется лежать. Caddy будет "долбиться" в мертвый апстрим.
3.  **Потеря контекста.** Я хочу открывать `docker-compose.yml` и видеть всё описание сервиса в одном месте: и порты, и вольюмы, и то, как он выставлен в интернет. Разрывать это на YAML-манифест и Caddyfile — значит усложнять отладку самому себе через полгода.

### Путь 2: Лейблы (The Docker Way)

Идея "Cloud Native": инфраструктура должна быть описательной. Я вешаю на контейнер лейбл `caddy: vpn.example.com`, и инфраструктура сама подстраивается.

**Главный страх:**
Чтобы это работало, нужно дать Caddy доступ к `/var/run/docker.sock`. В чатах по безопасности за такое бьют линейкой по рукам. Если Caddy скомпрометируют — злоумышленник получит root-доступ ко всему хосту через API Докера.

### Мое решение: Labels + Wollomatic Proxy

Я решил, что удобство эксплуатации (Self-Contained сервисы) для меня важнее пуризма Ansible. Но дыру в безопасности оставлять нельзя.

Поэтому моя архитектура выглядит так:

1.  **Caddy Docker Proxy** используется как контроллер. Он читает лейблы и строит маршруты на лету.
2.  **Никакого прямого доступа к сокету.** В `docker-compose` Caddy я не пробрасываю `/var/run/docker.sock`.
3.  **Wollomatic Socket Proxy.** Рядом поднимается крошечный sidecar-контейнер (написан на Go, scratch-образ). Он прокидывает сокет внутрь сети, но с жестким `allowlist`.

#### Конфиг безопасности

Я разрешаю только `GET` запросы к `containers` и `events`.

